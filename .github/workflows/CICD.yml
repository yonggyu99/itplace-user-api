# GitHub Actions 워크플로우 이름
name: CICD

# 워크플로우가 실행될 조건
on:
  push:
    branches: [ "develop" ]
  pull_request:
    branches: [ "develop" ]

# 워크플로우 실행에 필요한 권한
permissions:
  contents: read

# 실행될 작업들의 목록
jobs:
  # 'build' 작업
  build:
    runs-on: ubuntu-latest # 작업이 실행될 가상 환경
    steps:
      # 1. 소스 코드 체크아웃
      - uses: actions/checkout@v3

      # 2. OpenJDK 17 설치
      - name: Install JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'corretto'

      # 3. Gradle 빌드
      - name: Build with Gradle
        run: |
          echo ${{secrets.APPLICATION_SECRET}} | base64 --decode > ./src/main/resources/application-secret.yml
          chmod +x ./gradlew
          ./gradlew build -x test

      # 4. DockerHub 로그인
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 5. Docker 이미지 빌드 및 푸시 (효율적인 방식으로 통합)
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/live_server:latest

  # 'deploy' 작업
  deploy:
    needs: build # 'build' 작업이 성공해야 실행됨
    runs-on: ubuntu-latest
    steps:
      # 1. 배포 대상 서버 환경 설정 (Blue/Green)
      - name: Set target IP
        run: |
          STATUS=$(curl -L -o /dev/null -w "%{http_code}" "https://${{ secrets.LIVE_SERVER_DOMAIN }}/env") || true
          echo "Current status code: $STATUS"
          if [ $STATUS = 200 ]; then
            CURRENT_UPSTREAM=$(curl -L -s "https://${{ secrets.LIVE_SERVER_DOMAIN }}/env")
          else
            # /env 엔드포인트가 없거나 Nginx가 다운된 초기 상태. green부터 시작.
            echo "Could not determine current upstream or status was not 200. Defaulting to 'green'."
            CURRENT_UPSTREAM=green
          fi
          echo "CURRENT_UPSTREAM=$CURRENT_UPSTREAM" >> $GITHUB_ENV

          if [ "$CURRENT_UPSTREAM" = "blue" ]; then
            echo "CURRENT_PORT=8080" >> $GITHUB_ENV
            echo "STOPPED_PORT=8081" >> $GITHUB_ENV
            echo "TARGET_UPSTREAM=green" >> $GITHUB_ENV
          elif [ "$CURRENT_UPSTREAM" = "green" ]; then
            echo "CURRENT_PORT=8081" >> $GITHUB_ENV
            echo "STOPPED_PORT=8080" >> $GITHUB_ENV
            echo "TARGET_UPSTREAM=blue" >> $GITHUB_ENV
          else
            echo "Invalid CURRENT_UPSTREAM: $CURRENT_UPSTREAM"
            exit 1
          fi

      # 2. Docker Compose로 새로운 버전 실행
      - name: Docker compose
        uses: appleboy/ssh-action@v1.0.3 # 버전 고정 및 script_stop 제거
        with:
          username: ubuntu
          host: ${{ secrets.LIVE_SERVER_IP }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            sudo docker pull ${{ secrets.DOCKERHUB_USERNAME }}/live_server:latest
            sudo docker-compose -f docker-compose-${{env.TARGET_UPSTREAM}}.yml up -d

      # 3. 새로운 버전의 서버가 정상적으로 실행되었는지 확인
      - name: Check deploy server URL
        uses: jtalk/url-health-check-action@v3
        with:
          url: http://${{ secrets.LIVE_SERVER_IP }}:${{env.STOPPED_PORT}}/env
          max-attempts: 10
          retry-delay: 7s

      # 4. Nginx Upstream 변경하여 트래픽 전환
      - name: Change nginx upstream
        uses: appleboy/ssh-action@v1.0.3 # 버전 고정 및 script_stop 제거
        with:
          username: ubuntu
          host: ${{ secrets.LIVE_SERVER_IP }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            # Alpine 컨테이너를 위해 bash 대신 sh 사용
            sudo docker exec -i nginxserver sh -c 'echo "set \$service_url ${{ env.TARGET_UPSTREAM }};" > /etc/nginx/conf.d/service-env.inc && nginx -s reload'

      # 5. 이전 버전의 서버 중지 및 제거
      - name: Stop current server
        uses: appleboy/ssh-action@v1.0.3 # 버전 고정 및 script_stop 제거
        with:
          username: ubuntu
          host: ${{ secrets.LIVE_SERVER_IP }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            CONTAINER_NAME=${{env.CURRENT_UPSTREAM}}
            # 컨테이너가 실행 중인지 확인 후 중지/삭제
            if [ $(sudo docker ps -q -f "name=^${CONTAINER_NAME}$") ]; then
              echo "Stopping and removing container: ${CONTAINER_NAME}"
              sudo docker stop ${CONTAINER_NAME}
              sudo docker rm ${CONTAINER_NAME}
            else
              echo "Container ${CONTAINER_NAME} not found or not running. Skipping."
            fi
